#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import os
import sys
import json
import re
from pathlib import Path
from datetime import datetime, timedelta, date
from configparser import ConfigParser

# Robust, crossâ€‘platform path handling
config_location = Path.home() / '.config' / 'todo-ng'
datafile_location = Path.home() / '.local' / 'share' / 'todo-ng'
config_name = 'config'
datafile_json = 'todo.json'
due_string = 'Already due'

index_color = '\x1b[36m{}\x1b[0m'
date_color = '\x1b[32m{}\x1b[0m'
due_color = '\x1b[31m{}\x1b[0m'
today_color = '\x1b[4;33m{}\x1b[0m'
tomorrow_color = '\x1b[36m{}\x1b[0m'

esc_seq_reg = re.compile(r'\x1b[^m]*m')

WEEKDAY_MAP = {
    'mon': 0, 'tue': 1, 'wed': 2, 'thu': 3, 'fri': 4, 'sat': 5, 'sun': 6,
}

class TodoItem:
    def __init__(self, title: str, exp_date: datetime):
        self.title = title
        self.exp_date = exp_date

    @property
    def days_left(self):
        if self.exp_date is None:
            return 999
        return (self.exp_date.date() - date.today()).days

    def to_dict(self):
        return {
            'title': self.title,
            'exp_date': self.exp_date.strftime("%Y/%m/%d") if self.exp_date else None
        }

    def __str__(self):
        if self.exp_date is None:
            return self.title
        days_left = self.days_left
        if days_left == 0:
            return f"{self.title} (Due today)"
        elif days_left == 1:
            return f"{self.title} (Due tomorrow)"
        elif days_left > 1:
            if config['PY-TODO'].getboolean('detail_mode', fallback=False):
                week_start_str = config['PY-TODO'].get('week_start_day', 'Mon').lower()
                week_start_idx = WEEKDAY_MAP.get(week_start_str, 0)
                today = date.today()
                offset = (today.weekday() - week_start_idx) % 7
                this_week_start = today - timedelta(days=offset)
                next_week_start = this_week_start + timedelta(days=7)
                next_next_week_start = this_week_start + timedelta(days=14)
                d = self.exp_date.date()
                if this_week_start <= d < next_week_start:
                    return f"{self.title} (Due in {days_left} days, this {self.exp_date.strftime('%A')})"
                elif next_week_start <= d < next_next_week_start:
                    return f"{self.title} (Due in {days_left} days, next {self.exp_date.strftime('%A')})"
                else:
                    return f"{self.title} (Due in {days_left} days, on {self.exp_date.strftime('%a %e %b')})"
            return f"{self.title} (In {days_left} days)"
        else:
            return f"{self.title}\n    ({due_string})"

def maybe_color_str(message, color_fstr, predicate=lambda: True):
    if config['PY-TODO'].getboolean('color', fallback=False):
        stripped = esc_seq_reg.sub('', message)
        return color_fstr.format(stripped) if predicate() else message
    return message

def parse_date_str(exp_date_str):
    if not exp_date_str: return None
    if exp_date_str.endswith('d'):
        try:
            return datetime.today() + timedelta(days=int(exp_date_str[:-1]))
        except ValueError: sys.exit("Invalid day-count format.")
    try:
        return datetime.strptime(exp_date_str, "%Y/%m/%d")
    except ValueError: sys.exit("Invalid date format. Use YYYY/MM/DD or <days>d.")

class TodoList:
    def __init__(self):
        self.items = []

    def load(self):
        json_path = datafile_location / datafile_json
        
        if json_path.exists():
            try:
                with open(json_path, 'r') as f:
                    data = json.load(f)
                    self.items = [TodoItem(d['title'], parse_date_str(d['exp_date'])) for d in data]
            except Exception: 
                self.items = []

    def save(self):
        with open(datafile_location / datafile_json, 'w') as f:
            json.dump([item.to_dict() for item in self.items], f, indent=4)

    def list(self):
        display_items = self.items
        if config['PY-TODO'].getboolean('autosort', fallback=False):
            display_items = sorted(self.items, key=lambda i: i.days_left)

        if not display_items:
            print("No items left on the reminder.")
            return

        now = datetime.now()
        colored_date = maybe_color_str(now.strftime("%a, %e %b %Y, %k:%M"), date_color)
        print(f"\nToday is {colored_date}.")
        print(f"You have {maybe_color_str(f'[{len(display_items)}]', index_color)} item{'s' if len(display_items) != 1 else ''} left.")

        for idx, item in enumerate(display_items, start=1):
            item_str = str(item)
            idx_str = maybe_color_str(f"{idx}) ", index_color)
            if '(' in item_str:
                date_part = item_str[item_str.index('('):]
                date_part = maybe_color_str(date_part, due_color, lambda: due_string in date_part)
                date_part = maybe_color_str(date_part, date_color, lambda: due_string not in date_part)
                date_part = maybe_color_str(date_part, today_color, lambda: "today" in date_part)
                date_part = maybe_color_str(date_part, tomorrow_color, lambda: "tomorrow" in date_part)
                print(f"  {idx_str}{item.title}\n    {date_part}")
            else:
                print(f"  {idx_str}{item_str}")

def take_input(title_pos, date_pos, default_title=None):
    title = sys.argv[title_pos] if len(sys.argv) > title_pos else input(f"Title ({default_title}): " if default_title else "Title: ")
    exp_date_str = sys.argv[date_pos] if len(sys.argv) > date_pos else input("Due date (YYYY/MM/DD or <days>d): ")
    return title if title else default_title, exp_date_str

def usage():
    return (
        f"\nUsage: {sys.argv[0]} <argument>\n\n"
        "  a, -a, --add <title> <date or days as YYYY/MM/DD>   -- Add a new item.\n"
        "                                                      Ex: ./todo-ng -a \"Buy milk\" 10d\n"
        "                                                      Ex: ./todo-ng -a \"Buy milk\" 2025/12/30\n"
        "  e, -e, --edit <index> <title> <date or days>        -- Edit an item (uses displayed index).\n"
        "  m, -m, --move <index> <new index>                   -- Move an item (changes disk order).\n"
        "  r, -r, --remove <indices...>                        -- Remove items (uses displayed index).\n"
        "  l, -l, --list                                       -- List items.\n"
        "  h, -h, --help                                       -- Help.\n"
        "  v, -v, --version                                    -- Version.\n"
    )

if __name__ == '__main__':
    config_location.mkdir(parents=True, exist_ok=True)
    datafile_location.mkdir(parents=True, exist_ok=True)
    config = ConfigParser()
    config['PY-TODO'] = {'color': True, 'detail_mode': True, 'week_start_day': 'Mon', 'autosort': True}
    cfg_path = config_location / config_name
    if not cfg_path.is_file():
        with open(cfg_path, 'w+') as f: config.write(f)
    else: config.read(cfg_path)

    todo = TodoList()
    todo.load()

    active_items = sorted(todo.items, key=lambda i: i.days_left) if config['PY-TODO'].getboolean('autosort', fallback=False) else todo.items

    if len(sys.argv) <= 1:
        todo.list()
        sys.exit(0)

    cmd = sys.argv[1]

    if cmd in ['ls', 'l', '-l', '--list']:
        todo.list()

    elif cmd in ['a', 'add', '-a', '--add']:
        try:
            title, date_str = take_input(2, 3)
            todo.items.append(TodoItem(title, parse_date_str(date_str)))
            todo.list()
        except KeyboardInterrupt:
            print("\nCancelled.")
            todo.list()

    elif cmd in ['r', '-r', '--remove']:
        if len(sys.argv) >= 3:
            to_remove = []
            for i in sys.argv[2:]:
                try:
                    item_to_kill = active_items[int(i)-1]
                    to_remove.append(item_to_kill)
                except: print(f"Index {i} invalid.")
            todo.items = [it for it in todo.items if it not in to_remove]
            todo.list()
        else: print(usage())

    elif cmd in ['e', '-e', '--edit']:
        if len(sys.argv) >= 3:
            try:
                idx = int(sys.argv[2])
                item = active_items[idx-1]
                title, date_str = take_input(3, 4, item.title)
                item.title = title
                item.exp_date = parse_date_str(date_str)
                todo.list()
            except KeyboardInterrupt:
                print("\nCancelled.")
                todo.list()
            except: 
                print("Item does not exist.")
        else: print(usage())

    elif cmd in ['m', '-m', '--move']:
        if len(sys.argv) == 4:
            try:
                old_idx, new_idx = int(sys.argv[2]), int(sys.argv[3])
                item = active_items.pop(old_idx-1)
                todo.items.remove(item)
                todo.items.insert(new_idx-1, item)
                todo.list()
            except: print("Invalid movement.")
        else: print(usage())

    elif cmd in ['v', '-v', '--version']:
        print("todo-ng 1.1.0")
    else:
        print(usage())

    todo.save()
