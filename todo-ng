#!/usr/bin/env python3
# -*- encoding: utf-8 -*-

import os
import sys
import pickle
import re
from math import ceil
from enum import IntEnum
from pathlib import Path
from datetime import datetime, timedelta
from configparser import ConfigParser

config_location = str(Path.home()) + '/.config/todo-ng/'
datafile_location = str(Path.home()) + '/.local/share/todo-ng/'
config_name = 'config'
datafile_name = 'todo.dat'
due_string = 'Already due'

index_color = '\x1b[36m{}\x1b[0m'
date_color = '\x1b[32m{}\x1b[0m'
due_color = '\x1b[31m{}\x1b[0m'
today_color = '\x1b[4;33m{}\x1b[0m'
tomorrow_color = '\x1b[36m{}\x1b[0m'

esc_seq_reg = re.compile(r'\x1b[^m]*m')


class Weekday(IntEnum):
    MONDAY = 0
    SATURDAY = 5
    SUNDAY = 6


class TodoItem:
    def __init__(self, title: str, exp_date: datetime):
        self.title = title
        self.exp_date = exp_date

    @property
    def days_left(self):
        if self.exp_date is None:
            return 999
        return (self.exp_date - datetime.today()).days + 1

    def __eq__(self, other):
        return isinstance(other, TodoItem) and \
               self.title == other.title and \
               self.exp_date == other.exp_date

    def __str__(self):
        if self.exp_date is None:
            return self.title

        days_left = self.days_left

        if days_left == 0:
            return f"{self.title} (Due today)"
        elif days_left == 1:
            return f"{self.title} (Due tomorrow)"
        elif days_left > 1:
            output = f"{self.title} ("

            if config['PY-TODO'].getboolean('detail_mode', fallback=False):
                if config['PY-TODO'].get('week_start_day', 'Sun').lower() == 'mon':
                    last_weekday = Weekday.SUNDAY
                else:
                    last_weekday = Weekday.SATURDAY

                days_to_next_week = last_weekday - datetime.today().weekday()
                weeks_left = ceil((days_left - days_to_next_week) / 7)

                if weeks_left in (0, 1):
                    return (output +
                            f"Due in {days_left} days, "
                            f"{'this' if weeks_left == 0 else 'next'} "
                            f"{self.exp_date.strftime('%A')})")

                return (output +
                        f"Due in {days_left} days, on "
                        f"{self.exp_date.strftime('%a %e %b')})")

            return f"{self.title} (In {days_left} days)"
        else:
            return f"{self.title}\n\t({due_string})"


def maybe_color_str(message, color_fstr, predicate=lambda: True):
    if config['PY-TODO'].getboolean('color', fallback=False):
        stripped = esc_seq_reg.sub('', message)
        return color_fstr.format(stripped) if predicate() else message
    return message


def parse_date_str(exp_date_str):
    if exp_date_str == '':
        return None

    if exp_date_str.endswith('d'):
        try:
            day_count = int(exp_date_str[:-1])
            return datetime.today() + timedelta(days=day_count)
        except ValueError:
            print("Invalid day-count format.")
            sys.exit(1)

    try:
        return datetime.strptime(exp_date_str, "%Y/%m/%d")
    except ValueError:
        print("Invalid date format. Use YYYY/MM/DD or <days>d.")
        sys.exit(1)


class TodoList:
    def __init__(self):
        self.items = []

    def load(self):
        try:
            with open(datafile_location + datafile_name, 'rb') as f:
                self.items = pickle.load(f)
        except Exception:
            self.items = []

    def save(self):
        with open(datafile_location + datafile_name, 'wb') as f:
            pickle.dump(self.items, f)

    def add(self, title, exp_date):
        self.items.append(TodoItem(title, exp_date))

    def remove(self, indices):
        for idx in sorted(indices, reverse=True):
            if 1 <= idx <= len(self.items):
                del self.items[idx - 1]
            else:
                print(f"Index {idx} does not exist.")

    def move(self, old_index, new_index):
        if not (1 <= old_index <= len(self.items)):
            print("Source index does not exist.")
            return
        if not (1 <= new_index <= len(self.items) + 1):
            print("Destination index out of range.")
            return

        item = self.items.pop(old_index - 1)
        self.items.insert(new_index - 1, item)

    def sort(self):
        self.items.sort(key=lambda i: i.days_left)

    def list(self):
        if not self.items:
            print("No items left on the reminder.")
            return

        now = datetime.now()
        dt_string = now.strftime("%a, %e %b %Y, %k:%M")

        colored_date = maybe_color_str(dt_string, date_color)

        print(f"\nToday is {colored_date}.")

        count_str = f"[{len(self.items)}]"
        colored_count = maybe_color_str(count_str, index_color)

        print(f"You have {colored_count} item{'s' if len(self.items) != 1 else ''} left on the reminder.")

        for idx, item in enumerate(self.items, start=1):
            item_str = str(item)
            idx_str = maybe_color_str(f"{idx}) ", index_color)

            if '(' in item_str:
                date = item_str[item_str.index('('):]

                date = maybe_color_str(date, due_color, lambda: due_string in date)
                date = maybe_color_str(date, date_color, lambda: due_string not in date)
                date = maybe_color_str(date, today_color, lambda: "today" in date)
                date = maybe_color_str(date, tomorrow_color, lambda: "tomorrow" in date)

                print(f"  {idx_str}{item.title}\n\t{date}")
            else:
                print(f"  {idx_str}{item_str}")


def take_input(title_pos, date_pos, default_title=None):
    if default_title:
        title = sys.argv[title_pos] if len(sys.argv) > title_pos else \
                input(f"Title ({default_title}): ")
    else:
        title = sys.argv[title_pos] if len(sys.argv) > title_pos else \
                input("Title: ")

    exp_date_str = sys.argv[date_pos] if len(sys.argv) > date_pos else \
                   input("Due date (YYYY/MM/DD or <days>d) (Optional): ")

    return title if title else default_title, exp_date_str


def usage():
    return (
        "\nUsage: " + sys.argv[0] + " <argument>\n"
        "\ta -a --add add                              -- Add a new item.\n"
        "\ta -a --add <title> <date or days>           -- Add a new item with a title and due date.\n"
        "\te -e --edit <index>                         -- Edit an item.\n"
        "\te -e --edit <index> <title> <date or days>  -- Edit with provided values.\n"
        "\tm -m --move <index> <new index>             -- Move an item.\n"
        "\tr -r --remove <indices...>                  -- Remove items.\n"
        "\tl -l --list ls                              -- List items.\n"
        "\ts -s --sort                                 -- Sort items.\n"
        "\t-org --orgfile <filename>                   -- Import org todos.\n"
        "\n"
        "\th -h --help                                 -- Help.\n"
        "\tv -v --version                              -- Version.\n"
    )


def print_version():
    print(
        "\ntodo-ng 1.0.1 - with readline\n"
        "Copyleft George Abraham\n"
        "Based on py-todo by Marco Wang\n"
        "For license, see https://github.com/georgeabr/todo-ng\n"
    )


if __name__ == '__main__':
    Path(config_location).mkdir(parents=True, exist_ok=True)
    Path(datafile_location).mkdir(parents=True, exist_ok=True)

    global config
    config = ConfigParser()
    config['PY-TODO'] = {
        'color': True,
        'detail_mode': True,
        'week_start_day': 'Mon'
    }

    cfg_path = os.path.join(config_location, config_name)
    if not os.path.isfile(cfg_path):
        with open(cfg_path, 'w+') as f:
            config.write(f)
    else:
        config.read(cfg_path)

    todo = TodoList()
    todo.load()

    if len(sys.argv) <= 1:
        todo.list()
        print()
        sys.exit(0)

    cmd = sys.argv[1]

    if cmd in ['ls', 'l', '-l', '--list']:
        todo.list()

    elif cmd in ['a', 'add', '-a', '--add']:
        try:
            title, exp_date_str = take_input(2, 3)
            exp_date = parse_date_str(exp_date_str)
            todo.add(title, exp_date)
            todo.list()
            print()
        except KeyboardInterrupt:
            print()
            todo.list()

    elif cmd in ['r', '-r', '--remove']:
        if len(sys.argv) >= 3:
            try:
                indices = list(map(int, sys.argv[2:]))
                todo.remove(indices)
                todo.list()
                print()
            except ValueError:
                print("Invalid index.")
        else:
            print(usage())

    elif cmd in ['e', '-e', '--edit']:
        if len(sys.argv) >= 3:
            try:
                idx = int(sys.argv[2])
                item = todo.items[idx - 1]
                title, exp_date_str = take_input(3, 4, default_title=item.title)
                item.title = title
                item.exp_date = parse_date_str(exp_date_str)
                todo.list()
                print()
            except IndexError:
                print("Item does not exist.")
            except KeyboardInterrupt:
                print()
                todo.list()
        else:
            print(usage())

    elif cmd in ['m', '-m', '--move']:
        if len(sys.argv) == 4:
            try:
                old = int(sys.argv[2])
                new = int(sys.argv[3])
                todo.move(old, new)
                todo.list()
            except ValueError:
                print("Invalid index.")
        else:
            print(usage())

    elif cmd in ['s', '-s', '--sort']:
        todo.sort()
        todo.list()

    elif cmd in ['v', '-v', '--version']:
        print_version()

    else:
        print(usage())

    todo.save()


